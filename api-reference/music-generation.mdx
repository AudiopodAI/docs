---
title: "Music Generation"
description: "Create original music, instrumentals, rap, and samples from text descriptions using AudioPod AI's advanced music generation pipeline."
---

## Overview

AudioPod AI's Music Generation API uses the advanced Text to Music pipeline to transform text descriptions into original musical compositions. Generate complete songs with lyrics, instrumental tracks, rap music, audio samples, and perform advanced audio transformations.

### Key Features

- **Text-to-Music**: Generate complete musical compositions from text prompts and lyrics
- **Prompt-to-Instrumental**: Create instrumental tracks from text descriptions
- **Text-to-Rap**: Generate rap music with custom lyrics and beats
- **Text-to-Samples**: Create audio loops and samples for music production
- **Audio-to-Audio**: Transform existing audio using text prompts
- **Advanced Controls**: Fine-tune generation with guidance scales, steps, and seeds
- **Multiple Formats**: Output in WAV, MP3, FLAC formats
- **Royalty-Free**: All generated music is 100% royalty-free

## Authentication

All endpoints require authentication:
- **API Key**: `Authorization: Bearer your_api_key`
- **JWT Token**: `Authorization: Bearer your_jwt_token`

## Text-to-Music Generation

### Generate Music from Text and Lyrics

Create complete musical compositions with vocals from text prompts and lyrics.

<Tabs>
  <Tab title="Python">
    ```python
    from audiopod import Client

    # Initialize client
    client = Client()

    # Generate music with lyrics (simple)
    result = client.music.generate_music(
        prompt="Upbeat pop song with electronic beats and catchy melody",
        duration=120.0,
        display_name="My Pop Song",
        wait_for_completion=True
    )

    print(f"Music generated: {result.output_url}")

    # Download the music
    import requests
    audio_response = requests.get(result.output_url)
    with open("my_pop_song.wav", "wb") as f:
        f.write(audio_response.content)
    
    print("Music saved as my_pop_song.wav")

    # Advanced generation with custom parameters
    advanced_result = client.music.generate_music(
        prompt="Epic orchestral soundtrack with dramatic crescendos",
        duration=180.0,
        guidance_scale=12.0,
        num_inference_steps=80,
        seed=42,  # For reproducible results
        display_name="Epic Soundtrack",
        wait_for_completion=True
    )

    print(f"Advanced music generated: {advanced_result.output_url}")

    # Generate music asynchronously and check status
    async_job = client.music.generate_music(
        prompt="Relaxing ambient electronic music",
        duration=240.0,
        wait_for_completion=False  # Don't wait
    )

    print(f"Async job created: {async_job.id}")

    # Check job status
    status = client.music.get_music_job(async_job.id)
    print(f"Job status: {status.status}")
    
    # Like the generated track
    if status.status == 'completed':
        client.music.like_music_track(async_job.id)
        print("Track liked!")
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const { AudioPodClient } = require('audiopod-js');
    const fs = require('fs');

    // Initialize client
    const client = new AudioPodClient();

    async function generateMusic() {
      try {
        // Generate music with lyrics (simple)
        const result = await client.music.generateMusic({
          prompt: 'Upbeat pop song with electronic beats and catchy melody',
          duration: 120.0,
          displayName: 'My Pop Song',
          waitForCompletion: true
        });

        console.log(`Music generated: ${result.outputUrl}`);

        // Download the music
        const fetch = require('node-fetch');
        const audioResponse = await fetch(result.outputUrl);
        const buffer = await audioResponse.buffer();
        fs.writeFileSync('my_pop_song.wav', buffer);
        
        console.log('Music saved as my_pop_song.wav');

        // Advanced generation with custom parameters
        const advancedResult = await client.music.generateMusic({
          prompt: 'Epic orchestral soundtrack with dramatic crescendos',
          duration: 180.0,
          guidanceScale: 12.0,
          numInferenceSteps: 80,
          seed: 42,  // For reproducible results
          displayName: 'Epic Soundtrack',
          waitForCompletion: true
        });

        console.log(`Advanced music generated: ${advancedResult.outputUrl}`);

        // Generate music asynchronously and check status
        const asyncJob = await client.music.generateMusic({
          prompt: 'Relaxing ambient electronic music',
          duration: 240.0,
          waitForCompletion: false
        });

        console.log(`Async job created: ${asyncJob.id}`);

        // Check job status
        const status = await client.music.getMusicJob(asyncJob.id);
        console.log(`Job status: ${status.status}`);
        
        // Like the generated track
        if (status.status === 'completed') {
          await client.music.likeMusicTrack(asyncJob.id);
          console.log('Track liked!');
        }

      } catch (error) {
        console.error('Error:', error.message);
      }
    }

    generateMusic();
    ```
  </Tab>
  <Tab title="Raw HTTP">
    ```python
    import requests
    import time
    
    # Generate music
    music_request = {
        "prompt": "Upbeat pop song with electronic beats and catchy melody",
        "audio_duration": 120.0,
        "format": "wav",
        "genre_preset": "Pop",
        "display_name": "My Pop Song",
        "infer_step": 60,
        "guidance_scale": 15.0
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/text2music",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=music_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        job_id = job_data["job"]["id"]
        print(f"Music generation job created: {job_id}")
        print(f"Status: {job_data['job']['status']}")
        
        # Poll job status until completion
        while True:
            status_response = requests.get(
                f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/status",
                headers={"Authorization": f"Bearer {api_key}"}
            )
            
            if status_response.status_code == 200:
                status_data = status_response.json()
                print(f"Job status: {status_data['status']}")
                
                if status_data['status'] == 'completed':
                    music_url = status_data['output_url']
                    print(f"Music ready: {music_url}")
                    
                    # Download the music file
                    music_response = requests.get(music_url)
                    with open("my_pop_song.wav", "wb") as f:
                        f.write(music_response.content)
                    print("Music saved as my_pop_song.wav")
                    
                    # Like the track
                    like_response = requests.post(
                        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/like",
                        headers={"Authorization": f"Bearer {api_key}"}
                    )
                    if like_response.status_code == 200:
                        print("Track liked!")
                    break
                    
                elif status_data['status'] == 'failed':
                    print(f"Job failed: {status_data.get('error_message')}")
                    break
                    
            time.sleep(5)  # Wait 5 seconds before checking again
    ```
  </Tab>
  <Tab title="cURL">
    ```bash
    # Generate music
    JOB_RESPONSE=$(curl -s -X POST "https://api.audiopod.ai/api/v1/music/text2music" \
      -H "Authorization: Bearer $AUDIOPOD_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "prompt": "Upbeat pop song with electronic beats and catchy melody",
        "audio_duration": 120.0,
        "format": "wav",
        "genre_preset": "Pop",
        "display_name": "My Pop Song"
      }')

    # Extract job ID
    JOB_ID=$(echo $JOB_RESPONSE | jq -r '.job.id')
    echo "Music generation job created: $JOB_ID"

    # Poll job status
    while true; do
      STATUS_RESPONSE=$(curl -s -X GET "https://api.audiopod.ai/api/v1/music/jobs/$JOB_ID/status" \
        -H "Authorization: Bearer $AUDIOPOD_API_KEY")
      
      STATUS=$(echo $STATUS_RESPONSE | jq -r '.status')
      echo "Job status: $STATUS"
      
      if [ "$STATUS" = "completed" ]; then
        MUSIC_URL=$(echo $STATUS_RESPONSE | jq -r '.output_url')
        echo "Music ready: $MUSIC_URL"
        
        # Download the music
        curl -o my_pop_song.wav "$MUSIC_URL"
        echo "Music saved as my_pop_song.wav"
        
        # Like the track
        curl -s -X POST "https://api.audiopod.ai/api/v1/music/jobs/$JOB_ID/like" \
          -H "Authorization: Bearer $AUDIOPOD_API_KEY"
        echo "Track liked!"
        break
      elif [ "$STATUS" = "failed" ]; then
        echo "Job failed"
        break
      fi
      
      sleep 5
    done
    ```
  </Tab>
</Tabs>

**Request Parameters:**
- **`prompt`** (required): Text description of the desired music style and characteristics
- **`lyrics`** (optional): Song lyrics with structure tags like [Verse], [Chorus], [Bridge]
- **`duration`** (optional): Duration in seconds (-1 for auto, 1-600 seconds). Default: 120.0
  - Also accepts `audio_duration` for backward compatibility
  - Use -1 for automatic duration based on lyrics length
- **`format`** (optional): Output format (`wav`, `mp3`, `flac`). Default: `wav`
- **`genre_preset`** (optional): Genre preset (`Modern Pop`, `Rock`, `Hip Hop`, `Jazz`, `Classical`, `Electronic`, `Country`, `Folk`, `Blues`, `Reggae`, `Latin`, `R&B`, `Metal`, `Custom`)
- **`display_name`** (optional): Custom name for the generated track
- **`thumbnail_url`** (optional): URL for track thumbnail image

**Advanced Parameters:**
- **`infer_step`** (optional): Number of inference steps (1-200). Default: 60
- **`guidance_scale`** (optional): Classifier-free guidance scale (1.0-30.0). Default: 15.0
- **`scheduler_type`** (optional): Scheduler type (`euler`, etc.). Default: `euler`
- **`cfg_type`** (optional): CFG type (`apg`, etc.). Default: `apg`
- **`omega_scale`** (optional): Omega scale (1-20). Default: 10
- **`guidance_interval`** (optional): Guidance interval (0.0-1.0). Default: 0.5
- **`guidance_interval_decay`** (optional): Guidance decay (0.0-1.0). Default: 0.0
- **`min_guidance_scale`** (optional): Minimum guidance scale (1.0-10.0). Default: 3.0
- **`guidance_scale_text`** (optional): Text guidance scale (0.0-10.0). Default: 0.0
- **`guidance_scale_lyric`** (optional): Lyric guidance scale (0.0-10.0). Default: 0.0
- **`use_erg_tag`** (optional): Use ERG for tags. Default: true
- **`use_erg_lyric`** (optional): Use ERG for lyrics. Default: true
- **`use_erg_diffusion`** (optional): Use ERG for diffusion. Default: true
- **`manual_seeds`** (optional): Array of manual seeds for reproducibility

**Response:**

```json
{
  "job": {
    "id": 123,
    "task": "text2music",
    "status": "processing",
    "progress": null,
    "input_params": {
      "prompt": "Upbeat pop song with electronic beats and catchy melody",
      "lyrics": "[Verse 1]\\nWalking down the street\\nFeeling so complete\\n[Chorus]\\nThis is my time to shine",
      "duration": 120.0,
      "format": "wav",
      "genre_preset": "Modern Pop",
      "display_name": "My Pop Song",
      "infer_step": 60,
      "guidance_scale": 15.0
    },
    "output_path": null,
    "output_url": null,
    "output_paths": null,
    "output_urls": null,
    "created_at": "2024-01-15T10:30:00Z",
    "user_id": "user_123",
    "display_name": "My Pop Song",
    "thumbnail_url": null,
    "audio_duration": 120.0,
    "actual_seeds": null,
    "timecosts": null
  },
  "message": "Text-to-music generation started"
}
```

**Completed Job Response** (when status is "completed"):

```json
{
  "id": 123,
  "task": "text2music",
  "status": "completed",
  "progress": 100,
  "input_params": {
    "prompt": "Upbeat pop song with electronic beats",
    "lyrics": "[Verse 1]\\nWalking down the street...",
    "duration": 120.0,
    "format": "wav"
  },
  "output_path": "/generated/music_123.wav",
  "output_url": "https://api.audiopod.ai/download/music_123.wav",
  "output_paths": {
    "wav": "/generated/music_123.wav",
    "mp3": "/generated/music_123.mp3",
    "flac": "/generated/music_123.flac"
  },
  "output_urls": {
    "wav": "https://api.audiopod.ai/download/music_123.wav",
    "mp3": "https://api.audiopod.ai/download/music_123.mp3",
    "flac": "https://api.audiopod.ai/download/music_123.flac"
  },
  "created_at": "2024-01-15T10:30:00Z",
  "completed_at": "2024-01-15T10:35:30Z",
  "audio_duration": 120.5,
  "actual_seeds": [12345, 67890],
  "timecosts": {
    "preprocessing": 2.1,
    "generation": 312.4,
    "postprocessing": 5.8
  },
  "display_name": "My Pop Song",
  "thumbnail_url": null,
  "user_id": "user_123"
}
```

## Instrumental Generation

### Generate Instrumental Tracks

Create instrumental music without vocals from text prompts.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/prompt2instrumental
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "prompt": "Chill jazz instrumental with piano and saxophone",
      "audio_duration": 90.0,
      "format": "wav"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    instrumental_request = {
        "prompt": "Chill jazz instrumental with piano and saxophone",
        "audio_duration": 90.0,
        "format": "wav",
        "infer_step": 60,
        "guidance_scale": 15.0
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/prompt2instrumental",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=instrumental_request
    )
    ```
  </Tab>
</Tabs>

## Rap Generation

### Generate Rap Music

Create rap tracks with custom lyrics and beats.

<Tabs>
  <Tab title="Python">
    ```python
    from audiopod import Client

    client = Client()

    # Generate rap music (simple)
    rap_result = client.music.generate_rap(
        lyrics="[Verse 1]\nStarted from the bottom now we here\nGrinding every day throughout the year\n[Chorus]\nThis is our time to shine\nLeaving all the doubt behind",
        style="modern",
        tempo=120,
        display_name="My Rap Track",
        wait_for_completion=True
    )

    print(f"Rap generated: {rap_result.output_url}")

    # Advanced rap generation with custom parameters
    advanced_rap = client.music.generate_rap(
        lyrics="""
        [Intro]
        Yeah, AudioPod AI in the building
        Let's go!

        [Verse 1]
        Started with a vision, now we making it real
        Technology and music, that's the perfect deal
        Artificial intelligence helping artists create
        Breaking down the barriers, opening the gate

        [Chorus]
        We're the future of music generation
        AudioPod AI across the nation
        From text to beats, we make it all
        Stand up tall, never gonna fall

        [Verse 2]
        Every single bar crafted with precision
        Making music magic, that's our mission
        No more empty studios, no more writer's block
        AudioPod AI, we're solid as a rock

        [Outro]
        The revolution starts here, the future is now
        AudioPod AI, taking the vow
        """,
        style="trap",
        tempo=140,
        display_name="AudioPod AI Anthem",
        wait_for_completion=True
    )

    print(f"Advanced rap generated: {advanced_rap.output_url}")

    # Generate multiple rap variations
    rap_prompts = [
        {"lyrics": "[Verse]\nOld school vibes with a modern twist", "style": "old_school", "tempo": 90},
        {"lyrics": "[Verse]\nTrap beats hitting hard all night", "style": "trap", "tempo": 150},
        {"lyrics": "[Verse]\nConscious rap with a message to spread", "style": "conscious", "tempo": 100}
    ]

    rap_tracks = []
    for i, prompt in enumerate(rap_prompts):
        track = client.music.generate_rap(
            lyrics=prompt["lyrics"],
            style=prompt["style"],
            tempo=prompt["tempo"],
            display_name=f"Rap Variation {i+1}",
            wait_for_completion=True
        )
        rap_tracks.append(track)
        print(f"Generated {prompt['style']} rap: {track.output_url}")

    print(f"Generated {len(rap_tracks)} rap variations")
    ```
  </Tab>
  <Tab title="Node.js"
    ```javascript
    const { AudioPodClient } = require('audiopod-js');
    const client = new AudioPodClient();

    async function generateRapMusic() {
      try {
        // Generate rap music (simple)
        const rapResult = await client.music.generateRap({
          lyrics: '[Verse 1]\\nStarted from the bottom now we here\\nGrinding every day throughout the year\\n[Chorus]\\nThis is our time to shine\\nLeaving all the doubt behind',
          style: 'modern',
          tempo: 120,
          displayName: 'My Rap Track',
          waitForCompletion: true
        });

        console.log(`Rap generated: ${rapResult.outputUrl}`);

        // Advanced rap generation with custom parameters
        const advancedRap = await client.music.generateRap({
          lyrics: `
          [Intro]
          Yeah, AudioPod AI in the building
          Let's go!

          [Verse 1]
          Started with a vision, now we making it real
          Technology and music, that's the perfect deal
          Artificial intelligence helping artists create
          Breaking down the barriers, opening the gate

          [Chorus]
          We're the future of music generation
          AudioPod AI across the nation
          From text to beats, we make it all
          Stand up tall, never gonna fall
          `,
          style: 'trap',
          tempo: 140,
          displayName: 'AudioPod AI Anthem',
          waitForCompletion: true
        });

        console.log(`Advanced rap generated: ${advancedRap.outputUrl}`);

        // Generate multiple rap variations
        const rapPrompts = [
          { lyrics: '[Verse]\\nOld school vibes with a modern twist', style: 'old_school', tempo: 90 },
          { lyrics: '[Verse]\\nTrap beats hitting hard all night', style: 'trap', tempo: 150 },
          { lyrics: '[Verse]\\nConscious rap with a message to spread', style: 'conscious', tempo: 100 }
        ];

        const rapTracks = [];
        for (let i = 0; i < rapPrompts.length; i++) {
          const prompt = rapPrompts[i];
          const track = await client.music.generateRap({
            lyrics: prompt.lyrics,
            style: prompt.style,
            tempo: prompt.tempo,
            displayName: `Rap Variation ${i + 1}`,
            waitForCompletion: true
          });
          rapTracks.push(track);
          console.log(`Generated ${prompt.style} rap: ${track.outputUrl}`);
        }

        console.log(`Generated ${rapTracks.length} rap variations`);

      } catch (error) {
        console.error('Error generating rap:', error.message);
      }
    }

    generateRapMusic();
    ```
  </Tab>
  <Tab title="Raw HTTP">
    ```python
    rap_request = {
        "prompt": "Hard-hitting rap beat with heavy bass and trap drums",
        "lyrics": "[Verse 1]\\nStarted from the bottom now we here\\nGrinding every day throughout the year",
        "audio_duration": 150.0,
        "format": "wav",
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/text2rap",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=rap_request
    )
    ```
  </Tab>
</Tabs>

## Vocals Generation

### Generate Vocals from Lyrics

Create vocal tracks from lyrics without instrumental backing.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/lyric2vocals
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "prompt": "Female pop vocals with emotional delivery",
      "lyrics": "[Verse 1]\nWalking through the city lights\nEverything feels so bright",
      "audio_duration": 90.0
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    vocals_request = {
        "prompt": "Female pop vocals with emotional delivery",
        "lyrics": "[Verse 1]\\nWalking through the city lights\\nEverything feels so bright\\n[Chorus]\\nThis is our moment to shine",
        "audio_duration": 90.0,
        "format": "wav",
        "infer_step": 50,
        "guidance_scale": 7.5
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/lyric2vocals",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=vocals_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Vocals generation job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

## Sample Generation

### Generate Audio Samples

Create loops, one-shots, and samples for music production.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/text2samples
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "prompt": "Analog drum loop with vintage character",
      "sample_type": "loop",
      "audio_duration": 8.0,
      "tempo": 120
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    sample_request = {
        "prompt": "Analog drum loop with vintage character",
        "sample_type": "loop",
        "audio_duration": 8.0,
        "tempo": 120,
        "format": "wav"
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/text2samples",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=sample_request
    )
    ```
  </Tab>
</Tabs>

**Sample Parameters:**
- **`sample_type`**: Type of sample (`loop`, `one-shot`, etc.)
- **`tempo`**: Target tempo in BPM (60-200)
- **`audio_duration`**: Sample duration (-1 for auto, 1.0-120.0 seconds). Default: 8.0

## Audio-to-Audio Transformation

### Transform Audio with Text Prompts

Transform existing audio using text descriptions while preserving reference audio characteristics.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/audio2audio
    Authorization: Bearer {api_key}
    Content-Type: multipart/form-data
    
    prompt: "Transform this into an electronic dance version"
    ref_audio_strength: 0.7
    audio_duration: 120.0
    infer_step: 60
    guidance_scale: 15.0
    file: (audio file)
    ```
  </Tab>
  <Tab title="Python">
    ```python
    with open("reference_song.mp3", "rb") as audio_file:
        response = requests.post(
            "https://api.audiopod.ai/api/v1/music/audio2audio",
            headers={"Authorization": f"Bearer {api_key}"},
            data={
                "prompt": "Transform this into an electronic dance version",
                "ref_audio_strength": 0.7,     # Reference audio influence (0.0-1.0)
                "audio_duration": 120.0,       # Output duration
                "infer_step": 60,              # Inference steps
                "guidance_scale": 15.0,        # Guidance scale
                "display_name": "EDM Remix"
            },
            files={"file": audio_file}
        )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Audio transformation job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

**Parameters:**
- **`ref_audio_strength`**: How much the reference audio influences the output (0.0-1.0)
- **`audio_duration`**: Duration of the output audio (1-600 seconds)


## Music Extension

### Extend Existing Music

Extend an existing music track by adding more content to the end.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/extend
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "source_job_id": 123,
      "left_extend_length": 0.0,
      "right_extend_length": 30.0,
      "prompt": "Continue with the same energy and style",
      "lyrics": "[Outro]\nThe music goes on"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    extend_request = {
        "source_job_id": 123,           # Original music job ID
        "left_extend_length": 0.0,      # Seconds to add at beginning
        "right_extend_length": 30.0,    # Seconds to add at end
        "prompt": "Continue with the same energy and style",
        "lyrics": "[Outro]\\nThe music goes on",
        "audio_duration": 150.0,        # New total duration
        "display_name": "Extended Version"
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/extend",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=extend_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Extension job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

**Parameters:**
- **`source_job_id`** (required): ID of the original music generation job
- **`left_extend_length`** (optional): Seconds to add at beginning (0.0-60.0)
- **`right_extend_length`** (optional): Seconds to add at end (0.0-60.0, default: 30.0)
- **`prompt`** (required): Style description for extension
- **`lyrics`** (optional): Additional lyrics for extension
- **`extend_seeds`** (optional): Seeds for reproducibility

## Music Variations

### Create Music Retakes

Generate variations of existing music tracks.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/retake
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "original_job_id": 123,
      "retake_variance": 0.7,
      "display_name": "Jazz Variation"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    retake_request = {
        "original_job_id": 123,         # Original music job ID
        "retake_variance": 0.7,         # Variation strength (0.0-1.0)
        "retake_seeds": [12345, 67890], # Optional seeds
        "display_name": "Jazz Variation"
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/retake",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=retake_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Retake job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

**Parameters:**
- **`original_job_id`** (required): ID of the original music generation job
- **`retake_variance`** (optional): Variation strength (0.0-1.0, default: 0.5)
- **`retake_seeds`** (optional): Seeds for reproducible variations
- **`display_name`** (optional): Custom name for the variation

### Repaint Audio Sections

Modify specific sections of existing audio tracks.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/repaint
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "source_job_id": 123,
      "repaint_start": 30.0,
      "repaint_end": 60.0,
      "prompt": "Transform this section to jazz style",
      "lyrics": "[Verse 2]\nNew lyrics for this section"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    repaint_request = {
        "source_job_id": 123,           # Source music job ID
        "repaint_start": 30.0,          # Start time in seconds
        "repaint_end": 60.0,            # End time in seconds
        "prompt": "Transform this section to jazz style",
        "lyrics": "[Verse 2]\\nNew lyrics for this section",
        "audio_duration": 120.0,        # Total duration
        "display_name": "Repainted Version"
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/repaint",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=repaint_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Repaint job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

**Parameters:**
- **`source_job_id`** (optional): Source music generation job ID
- **`repaint_start`** (required): Start time in seconds to begin repainting
- **`repaint_end`** (required): End time in seconds to stop repainting
- **`prompt`** (required): New style description for the section
- **`lyrics`** (optional): New lyrics for the section

### Edit Existing Music

Comprehensive editing of existing music tracks.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/edit
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "source_job_id": 123,
      "edit_target_prompt": "Make it more electronic with synthesizers",
      "edit_target_lyrics": "[Verse 1]\nCompletely new lyrics",
      "edit_type": "remix",
      "edit_n_min": 0.3,
      "edit_n_max": 0.8
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    edit_request = {
        "source_job_id": 123,           # Source music job ID
        "edit_target_prompt": "Make it more electronic with synthesizers",
        "edit_target_lyrics": "[Verse 1]\\nCompletely new lyrics",
        "edit_type": "remix",           # "remix" or "only_lyrics"
        "edit_n_min": 0.3,             # Edit strength minimum
        "edit_n_max": 0.8,             # Edit strength maximum
        "edit_n_avg": 1,               # Edit averaging
        "audio_duration": 120.0,
        "display_name": "Remixed Version"
    }
    
    response = requests.post(
        "https://api.audiopod.ai/api/v1/music/edit",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=edit_request
    )
    
    if response.status_code == 200:
        job_data = response.json()
        print(f"Edit job: {job_data['job']['id']}")
    ```
  </Tab>
</Tabs>

**Parameters:**
- **`source_job_id`** (required): Source music generation job ID
- **`edit_target_prompt`** (required): New style description
- **`edit_target_lyrics`** (optional): New lyrics for the track
- **`edit_type`** (optional): Edit type - "remix" or "only_lyrics" (default: "remix")
- **`edit_n_min`** (optional): Edit strength minimum (0.0-1.0, default: 0.0)
- **`edit_n_max`** (optional): Edit strength maximum (0.0-1.0, default: 1.0)
- **`edit_n_avg`** (optional): Edit averaging (1-5, default: 1)

## Utility Endpoints

### Get Genre Presets

Retrieve available genre presets for music generation.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/presets
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    response = requests.get(
        "https://api.audiopod.ai/api/v1/music/presets",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        presets = response.json()
        print("Available genre presets:")
        for preset in presets["genre_presets"]:
            print(f"- {preset}")
    ```
  </Tab>
</Tabs>

## Job Management

### Get Job Status

Monitor the progress of music generation jobs.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/jobs/{job_id}/status
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/status",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        job = response.json()
        print(f"Status: {job['status']}")
        print(f"Progress: {job['progress']}%")
        
        if job["status"] == "COMPLETED":
            print("Music generation complete!")
            print(f"Output URL: {job['output_url']}")
            if job["output_urls"]:
                for format_name, url in job["output_urls"].items():
                    print(f"  {format_name.upper()}: {url}")
    ```
  </Tab>
</Tabs>

**Response (Completed Job):**

```json
{
  "id": 123,
  "task": "text2music",
  "status": "completed",
  "progress": 100,
  "input_params": {
    "prompt": "Upbeat pop song with electronic beats",
    "lyrics": "[Verse 1]\\nWalking down the street...",
    "duration": 120.0,
    "format": "wav"
  },
  "output_path": "/generated/music_123.wav",
  "output_url": "https://api.audiopod.ai/download/music_123.wav",
  "output_paths": {
    "wav": "/generated/music_123.wav",
    "mp3": "/generated/music_123.mp3",
    "flac": "/generated/music_123.flac"
  },
  "output_urls": {
    "wav": "https://api.audiopod.ai/download/music_123.wav",
    "mp3": "https://api.audiopod.ai/download/music_123.mp3",
    "flac": "https://api.audiopod.ai/download/music_123.flac"
  },
  "created_at": "2024-01-15T10:30:00Z",
  "completed_at": "2024-01-15T10:35:30Z",
  "audio_duration": 120.5,
  "actual_seeds": [12345, 67890],
  "timecosts": {
    "preprocessing": 2.1,
    "generation": 312.4,
    "postprocessing": 5.8
  },
  "display_name": "My Pop Song",
  "thumbnail_url": null,
  "user_id": "user_123"
}
```

### List Music Jobs

Get all music generation jobs for the authenticated user with enhanced filtering options.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/jobs?task=text2music&status=completed&song_type=song&liked=true&limit=50&skip=0
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    response = requests.get(
        "https://api.audiopod.ai/api/v1/music/jobs",
        headers={"Authorization": f"Bearer {api_key}"},
        params={
            "task": "text2music",      # Filter by specific task
            "status": "completed",     # Filter by status
            "song_type": "song",       # Filter by category: song, rap, instrumental, samples
            "liked": True,             # Filter liked tracks only
            "limit": 50,               # Number of results
            "skip": 0                  # Pagination offset
        }
    )
    
    if response.status_code == 200:
        jobs = response.json()
        for job in jobs:
            print(f"Job {job['id']}: {job['task']} - {job['status']}")
            if job.get("display_name"):
                print(f"  Title: {job['display_name']}")
    ```
  </Tab>
</Tabs>

**Query Parameters:**
- **`skip`** (optional): Number of jobs to skip for pagination. Default: 0
- **`limit`** (optional): Maximum number of jobs to return. Default: 50
- **`task`** (optional): Filter by specific task type (`text2music`, `text2rap`, `prompt2instrumental`, etc.)
- **`status`** (optional): Filter by job status (`pending`, `processing`, `completed`, `failed`)
- **`song_type`** (optional): Filter by category:
  - `song`: Full songs (text2music, lyric2vocals)
  - `rap`: Rap tracks (text2rap)
  - `instrumental`: Instrumental tracks (prompt2instrumental, text2samples)
  - `samples`: Audio samples (text2samples)
- **`liked`** (optional): Filter by user's liked status (`true` for liked only, `false` for non-liked)

### Get Liked Tracks

Get all tracks liked by the current user with filtering options.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/liked?song_type=rap&status=completed&limit=20
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    response = requests.get(
        "https://api.audiopod.ai/api/v1/music/liked",
        headers={"Authorization": f"Bearer {api_key}"},
        params={
            "song_type": "rap",        # Optional: filter by category
            "status": "completed",     # Optional: filter by status
            "limit": 20,               # Optional: results per page
            "skip": 0                  # Optional: pagination offset
        }
    )
    
    if response.status_code == 200:
        liked_tracks = response.json()
        print(f"Found {len(liked_tracks)} liked tracks")
        for track in liked_tracks:
            print(f"- {track['display_name']} ({track['task']})")
    ```
  </Tab>
</Tabs>

### Get Filter Statistics

Get statistics for building filter UI components.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/filters/stats
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    response = requests.get(
        "https://api.audiopod.ai/api/v1/music/filters/stats",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        stats = response.json()
        print(f"Total tracks: {stats['total_tracks']}")
        print(f"Liked tracks: {stats['liked_count']}")
        print("Song types distribution:")
        for song_type, count in stats['song_types'].items():
            print(f"  {song_type}: {count}")
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "total_tracks": 150,
  "liked_count": 25,
  "song_types": {
    "songs": 80,
    "rap": 30,
    "instrumental": 25,
    "remixes": 10,
    "edits": 5
  },
  "available_filters": {
    "song_types": ["songs", "rap", "instrumental", "remixes", "edits"],
    "interactions": ["liked"],
    "statuses": ["pending", "processing", "completed", "failed"]
  }
}
```

### Update Job Metadata

Update display name and thumbnail for an existing music job.

<Tabs>
  <Tab title="PATCH">
    ```http
    PATCH /api/v1/music/jobs/{job_id}
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "display_name": "Updated Track Name",
      "thumbnail_url": "https://example.com/new-thumbnail.jpg"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    update_data = {
        "display_name": "Updated Track Name",
        "thumbnail_url": "https://example.com/new-thumbnail.jpg"
    }
    
    response = requests.patch(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=update_data
    )
    
    if response.status_code == 200:
        updated_job = response.json()
        print(f"Updated job: {updated_job['display_name']}")
    ```
  </Tab>
</Tabs>

**Request Body:**
- **`display_name`** (optional): New display name for the track
- **`thumbnail_url`** (optional): New thumbnail URL for the track

### Delete Music Job

<Tabs>
  <Tab title="DELETE">
    ```http
    DELETE /api/v1/music/jobs/{job_id}
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    response = requests.delete(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Job deleted successfully")
    ```
  </Tab>
</Tabs>

## Music Interactions & Sharing

### Like/Unlike Music Track

<Tabs>
  <Tab title="POST (Like)">
    ```http
    POST /api/v1/music/jobs/{job_id}/like
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="DELETE (Unlike)">
    ```http
    DELETE /api/v1/music/jobs/{job_id}/like
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    
    # Like a track
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/like",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Track {result['message']}")
        print(f"Likes: {result['like_count']}, Dislikes: {result['dislike_count']}")
    
    # Unlike a track
    response = requests.delete(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/like",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "success": true,
  "message": "Track liked successfully",
  "interaction_type": "like",
  "like_count": 15,
  "dislike_count": 2,
  "share_count": 8,
  "comment_count": 5,
  "user_has_liked": true,
  "user_has_disliked": false
}
```

### Dislike/Remove Dislike from Track

<Tabs>
  <Tab title="POST (Dislike)">
    ```http
    POST /api/v1/music/jobs/{job_id}/dislike
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="DELETE (Remove Dislike)">
    ```http
    DELETE /api/v1/music/jobs/{job_id}/dislike
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    
    # Dislike a track
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/dislike",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Track {result['message']}")
        print(f"User status: liked={result['user_has_liked']}, disliked={result['user_has_disliked']}")
    
    # Remove dislike from track
    response = requests.delete(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/dislike",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    ```
  </Tab>
</Tabs>

### Share Music Track

Generate a shareable URL for a music track, enabling public access.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/jobs/{job_id}/share
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "platform": "twitter",
      "additional_data": {
        "campaign": "music_release",
        "source": "artist_dashboard"
      }
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    share_data = {
        "platform": "twitter",  # Optional: platform identifier
        "additional_data": {     # Optional: extra metadata
            "campaign": "music_release",
            "source": "artist_dashboard"
        }
    }
    
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/share",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=share_data
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Share URL: {result['share_url']}")
        print(f"Share count: {result['share_count']}")
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "success": true,
  "message": "Track shared successfully",
  "share_count": 9,
  "share_url": "https://audiopod.ai/shared/abc123def456",
  "share_token": "abc123def456"
}
```

### Get Track Statistics

Get public statistics for a music track.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/jobs/{job_id}/stats
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/stats",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        stats = response.json()
        print(f"Track Statistics:")
        print(f"  Likes: {stats['like_count']} ({stats['like_percentage']}%)")
        print(f"  Dislikes: {stats['dislike_count']} ({stats['dislike_percentage']}%)")
        print(f"  Shares: {stats['share_count']}")
        print(f"  Comments: {stats['comment_count']}")
        print(f"  Total interactions: {stats['total_interactions']}")
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "like_count": 42,
  "dislike_count": 3,
  "share_count": 15,
  "comment_count": 8,
  "total_interactions": 68,
  "like_percentage": 93.3,
  "dislike_percentage": 6.7
}
```

### Get User Interaction Status

Get the current user's interaction status with a specific track.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/jobs/{job_id}/interaction-status
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/interaction-status",
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    if response.status_code == 200:
        status = response.json()
        print(f"User interaction status:")
        print(f"  Has liked: {status['user_has_liked']}")
        print(f"  Has disliked: {status['user_has_disliked']}")
        print(f"  Can interact: {status['can_interact']}")
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "job_id": 123,
  "user_has_liked": true,
  "user_has_disliked": false,
  "can_interact": true
}
```

## Public Shared Tracks

These endpoints allow public access to shared music tracks without authentication.

### Get Shared Track

Access a publicly shared track using its share token.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/shared/{share_token}
    # No authentication required
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}"
        # No authentication headers needed
    )
    
    if response.status_code == 200:
        track = response.json()["track"]
        print(f"Shared Track: {track['display_name']}")
        print(f"Created by: {track['user_email']}")
        print(f"Duration: {track['audio_duration']}s")
        print(f"Likes: {track['like_count']}, Comments: {track['comment_count']}")
        
        # Available formats
        if track.get("output_urls"):
            print("Available formats:")
            for format_name, url in track["output_urls"].items():
                print(f"  {format_name.upper()}: {url}")
    ```
  </Tab>
</Tabs>

**Response:**
```json
{
  "track": {
    "id": 123,
    "task": "text2music",
    "status": "completed",
    "display_name": "My Awesome Song",
    "thumbnail_url": "https://example.com/thumb.jpg",
    "output_url": "https://api.audiopod.ai/download/music_123.wav",
    "output_urls": {
      "wav": "https://api.audiopod.ai/download/music_123.wav",
      "mp3": "https://api.audiopod.ai/download/music_123.mp3",
      "flac": "https://api.audiopod.ai/download/music_123.flac"
    },
    "created_at": "2024-01-15T10:30:00Z",
    "completed_at": "2024-01-15T10:35:30Z",
    "audio_duration": 120.5,
    "share_token": "abc123def456",
    "share_url": "https://audiopod.ai/shared/abc123def456",
    "is_shared": true,
    "shared_at": "2024-01-15T11:00:00Z",
    "user_email": "artist@example.com",
    "like_count": 42,
    "dislike_count": 3,
    "share_count": 15,
    "comment_count": 8,
    "total_interactions": 68,
    "like_percentage": 93.3,
    "dislike_percentage": 6.7,
    "prompt": "Upbeat pop song with electronic beats",
    "lyrics": "[Verse 1]\\nWalking down the street..."
  },
  "can_download": true,
  "can_comment": true,
  "can_interact": true
}
```

### Download Shared Track

Download a shared track in a specific format.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/shared/{share_token}/download?format=mp3
    # No authentication required
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    format_type = "mp3"  # wav, mp3, or flac
    
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/download",
        params={"format": format_type}
    )
    
    if response.status_code == 200:
        download_info = response.json()
        download_url = download_info["download_url"]
        filename = download_info["filename"]
        
        # Download the file
        audio_response = requests.get(download_url)
        with open(filename, "wb") as f:
            f.write(audio_response.content)
        
        print(f"Downloaded: {filename} ({download_info['format']} format)")
    ```
  </Tab>
</Tabs>

**Query Parameters:**
- **`format`** (optional): Desired format (`wav`, `mp3`, `flac`). Default: `wav`

**Response:**
```json
{
  "download_url": "https://api.audiopod.ai/download/presigned/music_123.mp3",
  "filename": "text2music-123.mp3",
  "format": "mp3",
  "expires_at": "2024-01-15T12:30:00Z"
}
```

### Like Shared Track (Anonymous)

Like a shared track without authentication (anonymous interaction).

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/shared/{share_token}/like
    # No authentication required - uses IP for anonymous identification
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    
    # Anonymous like (identified by IP address)
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/like"
        # No authentication headers - anonymous interaction
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Track {result['message']}")
        print(f"New like count: {result['like_count']}")
    ```
  </Tab>
</Tabs>

### Dislike Shared Track (Anonymous)

Dislike a shared track without authentication.

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/shared/{share_token}/dislike
    # No authentication required
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/dislike"
    )
    
    if response.status_code == 200:
        result = response.json()
        print(f"Track {result['message']}")
        print(f"Dislikes: {result['dislike_count']}")
    ```
  </Tab>
</Tabs>

## Comments System

### Add Comment to Shared Track

Add a comment to a publicly shared track (supports both authenticated and anonymous users).

<Tabs>
  <Tab title="POST (Anonymous)">
    ```http
    POST /api/v1/music/shared/{share_token}/comments
    Content-Type: application/json
    # No authentication required for anonymous comments
    
    {
      "content": "Amazing track! Love the beat.",
      "author_name": "Music Lover"
    }
    ```
  </Tab>
  <Tab title="POST (Authenticated)">
    ```http
    POST /api/v1/music/shared/{share_token}/comments
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "content": "Great work on this composition!"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    
    # Anonymous comment
    comment_data = {
        "content": "Amazing track! Love the beat.",
        "author_name": "Music Lover"  # Required for anonymous users
    }
    
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/comments",
        headers={"Content-Type": "application/json"},
        json=comment_data
    )
    
    # Authenticated comment (author_name not needed - uses user's name)
    authenticated_comment = {
        "content": "Great work on this composition!"
    }
    
    auth_response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/comments",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=authenticated_comment
    )
    
    if response.status_code == 200:
        comment = response.json()
        print(f"Comment added by {comment['author_name']}")
    ```
  </Tab>
</Tabs>

**Request Body:**
- **`content`** (required): Comment text content
- **`author_name`** (required for anonymous): Display name for anonymous comments

**Response:**
```json
{
  "id": 456,
  "content": "Amazing track! Love the beat.",
  "author_name": "Music Lover",
  "created_at": "2024-01-15T12:00:00Z",
  "updated_at": "2024-01-15T12:00:00Z",
  "is_edited": false,
  "user_id": null
}
```

### Get Comments for Shared Track

Retrieve comments for a shared track with pagination.

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/shared/{share_token}/comments?skip=0&limit=20
    # No authentication required
    ```
  </Tab>
  <Tab title="Python">
    ```python
    share_token = "abc123def456"
    
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/shared/{share_token}/comments",
        params={
            "skip": 0,      # Pagination offset
            "limit": 20     # Comments per page
        }
    )
    
    if response.status_code == 200:
        comments_data = response.json()
        comments = comments_data["comments"]
        
        print(f"Showing {len(comments)} of {comments_data['total_count']} comments")
        for comment in comments:
            print(f"{comment['author_name']}: {comment['content']}")
            print(f"  Posted: {comment['created_at']}")
    ```
  </Tab>
</Tabs>

**Query Parameters:**
- **`skip`** (optional): Number of comments to skip. Default: 0
- **`limit`** (optional): Maximum comments to return. Default: 50

**Response:**
```json
{
  "comments": [
    {
      "id": 456,
      "content": "Amazing track! Love the beat.",
      "author_name": "Music Lover",
      "created_at": "2024-01-15T12:00:00Z",
      "updated_at": "2024-01-15T12:00:00Z",
      "is_edited": false,
      "user_id": null
    },
    {
      "id": 457,
      "content": "Great composition!",
      "author_name": "john@example.com",
      "created_at": "2024-01-15T12:15:00Z",
      "updated_at": "2024-01-15T12:15:00Z",
      "is_edited": false,
      "user_id": "user_789"
    }
  ],
  "total_count": 8,
  "has_more": false
}
```

### Add Comment to Own Track (Authenticated)

Add a comment to your own track (requires authentication).

<Tabs>
  <Tab title="POST">
    ```http
    POST /api/v1/music/jobs/{job_id}/comments
    Authorization: Bearer {api_key}
    Content-Type: application/json
    
    {
      "content": "Thanks everyone for the feedback!"
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    comment_data = {
        "content": "Thanks everyone for the feedback!"
    }
    
    response = requests.post(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/comments",
        headers={
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        },
        json=comment_data
    )
    
    if response.status_code == 200:
        comment = response.json()
        print(f"Comment added: {comment['content']}")
    ```
  </Tab>
</Tabs>

### Get Comments for Own Track

<Tabs>
  <Tab title="GET">
    ```http
    GET /api/v1/music/jobs/{job_id}/comments?skip=0&limit=50
    Authorization: Bearer {api_key}
    ```
  </Tab>
  <Tab title="Python">
    ```python
    job_id = 123
    response = requests.get(
        f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/comments",
        headers={"Authorization": f"Bearer {api_key}"},
        params={"skip": 0, "limit": 50}
    )
    
    if response.status_code == 200:
        comments_data = response.json()
        print(f"Track has {comments_data['total_count']} comments")
    ```
  </Tab>
</Tabs>

### Download Generated Music

<Tabs>
  <Tab title="Python">
    ```python
    def download_generated_music(job_id, api_key, format_preference="wav"):
        """Download generated music from completed job"""
        
        # Get job details
        response = requests.get(
            f"https://api.audiopod.ai/api/v1/music/jobs/{job_id}/status",
            headers={"Authorization": f"Bearer {api_key}"}
        )
        
        if response.status_code != 200:
            return {"error": "Job not found"}
        
        job = response.json()
        
        if job["status"] != "COMPLETED":
            return {"error": f"Job not completed. Status: {job['status']}"}
        
        # Choose download URL
        download_url = None
        if job.get("output_urls") and format_preference in job["output_urls"]:
            download_url = job["output_urls"][format_preference]
        elif job.get("output_url"):
            download_url = job["output_url"]
        else:
            return {"error": "No download URL available"}
        
        # Download audio
        audio_response = requests.get(download_url)
        if audio_response.status_code == 200:
            filename = f"music_{job_id}.{format_preference}"
            with open(filename, "wb") as f:
                f.write(audio_response.content)
            
            return {
                "success": True,
                "filename": filename,
                "duration": job.get("audio_duration"),
                "format": format_preference,
                "display_name": job.get("display_name")
            }
        else:
            return {"error": "Failed to download audio"}
    
    # Usage
    result = download_generated_music(123, "your_api_key", "mp3")
    if result.get("success"):
        print(f"Downloaded: {result['filename']}")
        print(f"Duration: {result['duration']} seconds")
    ```
  </Tab>
</Tabs>

## Genre Presets

Available genre presets for quick configuration (these replace the `prompt` parameter):

| Preset | Description | Generated Prompt |
|--------|-------------|------------------|
| `Modern Pop` | Contemporary pop music | pop, synth, drums, guitar, 120 bpm, upbeat, catchy, vibrant, female vocals, polished vocals |
| `Rock` | Rock and alternative | rock, electric guitar, drums, bass, 130 bpm, energetic, rebellious, gritty, male vocals, raw vocals |
| `Hip Hop` | Hip-hop and rap | hip hop, 808 bass, hi-hats, synth, 90 bpm, bold, urban, intense, male vocals, rhythmic vocals |
| `Country` | Country and folk | country, acoustic guitar, steel guitar, fiddle, 100 bpm, heartfelt, rustic, warm, male vocals, twangy vocals |
| `EDM` | Electronic dance music | edm, synth, bass, kick drum, 128 bpm, euphoric, pulsating, energetic, instrumental |
| `Reggae` | Reggae and ska | reggae, guitar, bass, drums, 80 bpm, chill, soulful, positive, male vocals, smooth vocals |
| `Classical` | Orchestral and chamber | classical, orchestral, strings, piano, 60 bpm, elegant, emotive, timeless, instrumental |
| `Jazz` | Jazz and fusion | jazz, saxophone, piano, double bass, 110 bpm, smooth, improvisational, soulful, male vocals, crooning vocals |
| `Metal` | Heavy metal | metal, electric guitar, double kick drum, bass, 160 bpm, aggressive, intense, heavy, male vocals, screamed vocals |
| `R&B` | R&B and soul | r&b, synth, bass, drums, 85 bpm, sultry, groovy, romantic, female vocals, silky vocals |
| `Folk` | Acoustic folk | folk, acoustic guitar, harmonica, 90 bpm, organic, traditional, storytelling |
| `Blues` | Blues and R&B | blues, guitar, harmonica, 80 bpm, emotional, soulful, traditional |
| `Latin` | Latin and world music | latin, guitar, percussion, 110 bpm, rhythmic, festive, cultural |
| `Custom` | No preset applied | Use your own custom prompt |

## Advanced Parameters

### Fine-Tuning Generation

For advanced users who want precise control over the generation process:

```json
{
  "infer_step": 60,                    // Inference steps (1-200)
  "guidance_scale": 15.0,              // CFG scale (1.0-30.0)
  "scheduler_type": "euler",           // Scheduler type
  "cfg_type": "apg",                   // CFG type
  "omega_scale": 10,                   // Omega scale (1-20)
  "guidance_interval": 0.5,            // Guidance interval (0.0-1.0)
  "guidance_interval_decay": 0.0,      // Guidance decay (0.0-1.0)
  "min_guidance_scale": 3.0,           // Min guidance (1.0-10.0)
  "guidance_scale_text": 0.0,         // Text guidance (0.0-10.0)
  "guidance_scale_lyric": 0.0,         // Lyric guidance (0.0-10.0)
  "use_erg_tag": true,                 // Use ERG for tags
  "use_erg_lyric": true,               // Use ERG for lyrics
  "use_erg_diffusion": true,           // Use ERG for diffusion
  "manual_seeds": [12345, 67890]       // Manual seeds for reproducibility
}
```

### Output Formats

- **`wav`**: Uncompressed, highest quality (default)
- **`mp3`**: Compressed, smaller file size
- **`flac`**: Lossless compression, good quality/size balance

## Error Handling

<AccordionGroup>
  <Accordion title="400 Bad Request - Invalid Parameters">
    **Causes:** - Invalid audio duration (outside 1-600 seconds) - Invalid format specified - Missing required parameters
    **Solutions:** - Check parameter ranges and formats - Ensure required fields are provided - Validate lyrics format
  </Accordion>

  <Accordion title="413 Payload Too Large">
    **Causes:** - Audio file for audio2audio exceeds size limits - Very large reference files
    **Solutions:** - Compress reference audio files - Use supported formats (MP3, WAV, M4A) - Ensure files are under 100MB
  </Accordion>

  <Accordion title="422 Processing Error - Generation Failed">
    **Causes:** - Prompt too vague or conflicting - Invalid reference audio - Generation timeout
    **Solutions:** - Write clearer, more specific prompts - Use high-quality reference audio - Try shorter durations - Retry with different parameters
  </Accordion>

  <Accordion title="402 Payment Required - Insufficient Credits">
    **Causes:** - Not enough credits for the requested duration - Account credit balance too low
    **Solutions:** - Purchase additional credits - Check credit requirements before generation - Use shorter durations for testing
  </Accordion>
</AccordionGroup>

## Pricing

Music generation pricing based on actual credit costs:

| Service | Cost | Description |
|---------|------|-------------|
| Text-to-Music | 1320 credits/minute | Complete songs with lyrics |
| Instrumental | 1320 credits/minute | Instrumental tracks |
| Text-to-Rap | 1320 credits/minute | Rap music with beats |
| Text-to-Samples | 176 credits/8 seconds | Audio loops and samples (1320/60*8) |
| Audio-to-Audio | 1320 credits/minute | Audio transformation |


### Cost Examples

| Duration | Service | Credits | USD Cost |
|----------|---------|---------|----------|
| 2 minutes | Text-to-Music | 2640 | $0.35 |
| 1 minute | Instrumental | 1320 | $0.18 |
| 8 seconds | Sample Loop | 176 | $0.02 |
| 90 seconds | Audio-to-Audio | 1980 | $0.26 |


### Cost Optimization Tips

1. **Start with shorter durations** for testing and iteration
2. **Use instrumental mode** for background music (lower cost)
3. **Generate samples first** then extend successful ones
4. **Batch similar requests** to optimize workflows

## Best Practices

### Effective Prompt Writing

** Good Prompts:**
- "Upbeat indie rock with jangly guitars, 120 BPM, perfect for summer commercial"
- "Mystical ambient music for fantasy game, ethereal pads and flute melody"
- "Hard-hitting trap beat with heavy 808s and crisp hi-hats"

** Avoid:**
- "Make good music" (too vague)
- "Classical electronic jazz fusion" (conflicting styles)
- Extremely long prompts with too many requirements

### Lyric Structure Tags

For best results with lyrics, use these structure tags:

```
[Intro]
[Verse 1]
[Pre-Chorus]
[Chorus]
[Verse 2]
[Chorus]
[Bridge]
[Chorus]
[Outro]
```

### Advanced Generation Tips

```python
# For consistent results, use manual seeds
{
  "manual_seeds": [12345, 67890],
  "infer_step": 60,
  "guidance_scale": 15.0
}

# For creative variations, omit seeds
{
  "infer_step": 80,  # Higher steps for more detail
  "guidance_scale": 12.0  # Lower for more creativity
}

# For specific genres, use presets
{
  "genre_preset": "Electronic",
  "prompt": "Describe specific elements you want"
}
```

## Next Steps

<Columns cols={2}>
  <Card title="Stem Separation" icon="music" href="/api-reference/stem-separation">
    Separate generated music into individual instrument tracks.
  </Card>
  <Card title="Noise Reduction" icon="volume-x" href="/api-reference/noise-reduction">
    Enhance and clean up your generated music.
  </Card>
</Columns>
